name: Release On Main

on:
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  actions: write
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Compute next version
        id: version
        shell: bash
        run: |
          set -euo pipefail

          latest_tag="$(git tag --list 'v*' | sort -V | tail -n 1)"
          if [[ -z "$latest_tag" ]]; then
            latest_tag="v0.0.0"
          fi

          current_sha="$(git rev-parse HEAD)"
          if git describe --tags --exact-match "$current_sha" >/dev/null 2>&1; then
            echo "Head is already tagged; skipping release."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$latest_tag" == "v0.0.0" ]]; then
            range=""
            commits="$(git log --pretty=%B)"
          else
            range="${latest_tag}..HEAD"
            commits="$(git log "$range" --pretty=%B)"
          fi

          if [[ -z "${commits//[[:space:]]/}" ]]; then
            echo "No commits since last tag; skipping release."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          major=0
          minor=0
          patch=0

          if echo "$commits" | grep -Eq 'BREAKING CHANGE|^[a-zA-Z]+\([^)]+\)!:|^[a-zA-Z]+!:'; then
            major=1
          elif echo "$commits" | grep -Eq '^feat(\([^)]+\))?:'; then
            minor=1
          elif echo "$commits" | grep -Eq '^(fix|chore|docs|refactor|perf|test|build|ci)(\([^)]+\))?:'; then
            patch=1
          else
            patch=1
          fi

          base="${latest_tag#v}"
          IFS='.' read -r vmajor vminor vpatch <<< "$base"
          vmajor=${vmajor:-0}
          vminor=${vminor:-0}
          vpatch=${vpatch:-0}

          if [[ "$major" -eq 1 ]]; then
            vmajor=$((vmajor + 1))
            vminor=0
            vpatch=0
          elif [[ "$minor" -eq 1 ]]; then
            vminor=$((vminor + 1))
            vpatch=0
          else
            vpatch=$((vpatch + 1))
          fi

          next_tag="v${vmajor}.${vminor}.${vpatch}"

          if git rev-parse "$next_tag" >/dev/null 2>&1; then
            echo "Tag $next_tag already exists; skipping release."
            echo "should_release=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "latest_tag=$latest_tag" >> "$GITHUB_OUTPUT"
          echo "next_tag=$next_tag" >> "$GITHUB_OUTPUT"
          echo "should_release=true" >> "$GITHUB_OUTPUT"

      - name: Create release
        if: steps.version.outputs.should_release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          tag="${{ steps.version.outputs.next_tag }}"
          gh release create "$tag" \
            --target "$GITHUB_SHA" \
            --title "$tag" \
            --generate-notes

      - name: Trigger binary build and stable tap update
        if: steps.version.outputs.should_release == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh workflow run "Build Release Binary" \
            --ref main \
            -f release_tag="${{ steps.version.outputs.next_tag }}"

      - name: Summary
        run: |
          echo "should_release=${{ steps.version.outputs.should_release }}"
          echo "latest_tag=${{ steps.version.outputs.latest_tag }}"
          echo "next_tag=${{ steps.version.outputs.next_tag }}"
